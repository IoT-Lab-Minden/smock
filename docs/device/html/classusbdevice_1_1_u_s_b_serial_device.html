<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Smock - Device: usbdevice::USBSerialDevice Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="icon_small.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Smock - Device
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>usbdevice</b></li><li class="navelem"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html">USBSerialDevice</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classusbdevice_1_1_u_s_b_serial_device-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">usbdevice::USBSerialDevice Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Device for serial communication.  
 <a href="classusbdevice_1_1_u_s_b_serial_device.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_u_s_b_serial_device_8h_source.html">USBSerialDevice.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad2721ebfd4cb57801e8137482a518edf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html#ad2721ebfd4cb57801e8137482a518edf">initBuffer</a> ()</td></tr>
<tr class="memdesc:ad2721ebfd4cb57801e8137482a518edf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the transmit and receive buffers.  <a href="#ad2721ebfd4cb57801e8137482a518edf">More...</a><br /></td></tr>
<tr class="separator:ad2721ebfd4cb57801e8137482a518edf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ddf5d93912f8805380c077d7a2a9dc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html#ab8ddf5d93912f8805380c077d7a2a9dc">flushReceiveBuffer</a> ()</td></tr>
<tr class="memdesc:ab8ddf5d93912f8805380c077d7a2a9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flushes the receive buffer which is accessible from the user.  <a href="#ab8ddf5d93912f8805380c077d7a2a9dc">More...</a><br /></td></tr>
<tr class="separator:ab8ddf5d93912f8805380c077d7a2a9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d8813297fdb77ae424cfe22eabadac"><td class="memItemLeft" align="right" valign="top">tUSBDCDCDevice *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html#ae6d8813297fdb77ae424cfe22eabadac">getSerialDevice</a> ()</td></tr>
<tr class="memdesc:ae6d8813297fdb77ae424cfe22eabadac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the g_sCDCDevice attribute.  <a href="#ae6d8813297fdb77ae424cfe22eabadac">More...</a><br /></td></tr>
<tr class="separator:ae6d8813297fdb77ae424cfe22eabadac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea702b8353c899e212b7b20ec8c2774d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html#aea702b8353c899e212b7b20ec8c2774d">connected</a> ()</td></tr>
<tr class="memdesc:aea702b8353c899e212b7b20ec8c2774d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when new connection appeared.  <a href="#aea702b8353c899e212b7b20ec8c2774d">More...</a><br /></td></tr>
<tr class="separator:aea702b8353c899e212b7b20ec8c2774d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97d2e06a99ef4caceff956843f6036de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html#a97d2e06a99ef4caceff956843f6036de">disconnected</a> ()</td></tr>
<tr class="memdesc:a97d2e06a99ef4caceff956843f6036de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when a conncection is closed.  <a href="#a97d2e06a99ef4caceff956843f6036de">More...</a><br /></td></tr>
<tr class="separator:a97d2e06a99ef4caceff956843f6036de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3884b6ffd4ec034716b20f5b330d085"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html#af3884b6ffd4ec034716b20f5b330d085">write</a> (uint8_t *data, uint32_t length)</td></tr>
<tr class="memdesc:af3884b6ffd4ec034716b20f5b330d085"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data in transmit buffer.  <a href="#af3884b6ffd4ec034716b20f5b330d085">More...</a><br /></td></tr>
<tr class="separator:af3884b6ffd4ec034716b20f5b330d085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa54a952b46225b35c90c97b5b5896ff8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html#aa54a952b46225b35c90c97b5b5896ff8">popReceiveBuffer</a> ()</td></tr>
<tr class="memdesc:aa54a952b46225b35c90c97b5b5896ff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns top of queue.  <a href="#aa54a952b46225b35c90c97b5b5896ff8">More...</a><br /></td></tr>
<tr class="separator:aa54a952b46225b35c90c97b5b5896ff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57629924cbdfad86e932cda3c46acce5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html#a57629924cbdfad86e932cda3c46acce5">pushReceiveBuffer</a> (uint8_t data)</td></tr>
<tr class="memdesc:a57629924cbdfad86e932cda3c46acce5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds add the end of the queue.  <a href="#a57629924cbdfad86e932cda3c46acce5">More...</a><br /></td></tr>
<tr class="separator:a57629924cbdfad86e932cda3c46acce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a623767d4a33912d98fb84482c4e54774"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html#a623767d4a33912d98fb84482c4e54774">getReceiveBufferLength</a> ()</td></tr>
<tr class="memdesc:a623767d4a33912d98fb84482c4e54774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the length of the user accessible reciveBuffer.  <a href="#a623767d4a33912d98fb84482c4e54774">More...</a><br /></td></tr>
<tr class="separator:a623767d4a33912d98fb84482c4e54774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc9ec56cb3fd6e82d5dc535a12b7206"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html#a7bc9ec56cb3fd6e82d5dc535a12b7206">getRxEventCount</a> ()</td></tr>
<tr class="memdesc:a7bc9ec56cb3fd6e82d5dc535a12b7206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Getter for the number of receive events.  <a href="#a7bc9ec56cb3fd6e82d5dc535a12b7206">More...</a><br /></td></tr>
<tr class="separator:a7bc9ec56cb3fd6e82d5dc535a12b7206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c7f10fd7e7526f23e40525c7e2c82a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html#a98c7f10fd7e7526f23e40525c7e2c82a">commandStatusUpdated</a> ()</td></tr>
<tr class="memdesc:a98c7f10fd7e7526f23e40525c7e2c82a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates weather the COMMAND_STATUS_UPDATE flag is that.  <a href="#a98c7f10fd7e7526f23e40525c7e2c82a">More...</a><br /></td></tr>
<tr class="separator:a98c7f10fd7e7526f23e40525c7e2c82a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871027e87d727d295f96489f15d29d2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html#a871027e87d727d295f96489f15d29d2f">resetCommandStatusFlag</a> ()</td></tr>
<tr class="memdesc:a871027e87d727d295f96489f15d29d2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets command status flag.  <a href="#a871027e87d727d295f96489f15d29d2f">More...</a><br /></td></tr>
<tr class="separator:a871027e87d727d295f96489f15d29d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca2b3c4990e877940768e3ee02e9400"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html#acca2b3c4990e877940768e3ee02e9400">readBuffer</a> ()</td></tr>
<tr class="memdesc:acca2b3c4990e877940768e3ee02e9400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes data from the rxBuffer into the receive buffer.  <a href="#acca2b3c4990e877940768e3ee02e9400">More...</a><br /></td></tr>
<tr class="separator:acca2b3c4990e877940768e3ee02e9400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1bcae7c6437cd73d02915e32403514"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html#a6f1bcae7c6437cd73d02915e32403514">USBUARTPrimeTransmit</a> ()</td></tr>
<tr class="separator:a6f1bcae7c6437cd73d02915e32403514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c912443871746f9eef7b41c8511442f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html#a3c912443871746f9eef7b41c8511442f">CheckForSerialStateChange</a> (const tUSBDCDCDevice *psDevice, int32_t i32Errors)</td></tr>
<tr class="memdesc:a3c912443871746f9eef7b41c8511442f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks the error flags and reacts accordingly.  <a href="#a3c912443871746f9eef7b41c8511442f">More...</a><br /></td></tr>
<tr class="separator:a3c912443871746f9eef7b41c8511442f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46805f59e2e3bf567348897f311c9b95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html#a46805f59e2e3bf567348897f311c9b95">SetControlLineState</a> (uint16_t ui16State)</td></tr>
<tr class="memdesc:a46805f59e2e3bf567348897f311c9b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the state of the RS232 RTS and DTR signals.  <a href="#a46805f59e2e3bf567348897f311c9b95">More...</a><br /></td></tr>
<tr class="separator:a46805f59e2e3bf567348897f311c9b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae42671dfee2a661cd0a88a52ca52e289"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html#ae42671dfee2a661cd0a88a52ca52e289">SetLineCoding</a> (tLineCoding *psLineCoding)</td></tr>
<tr class="memdesc:ae42671dfee2a661cd0a88a52ca52e289"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the communication parameters to use on the UART.  <a href="#ae42671dfee2a661cd0a88a52ca52e289">More...</a><br /></td></tr>
<tr class="separator:ae42671dfee2a661cd0a88a52ca52e289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace75598fb46d690a478f7cf924c497ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html#ace75598fb46d690a478f7cf924c497ad">GetLineCoding</a> (tLineCoding *psLineCoding)</td></tr>
<tr class="memdesc:ace75598fb46d690a478f7cf924c497ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the communication parameters in use on the UART.  <a href="#ace75598fb46d690a478f7cf924c497ad">More...</a><br /></td></tr>
<tr class="separator:ace75598fb46d690a478f7cf924c497ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9eadeec256969f8c736f7ded61f5fa0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html#ad9eadeec256969f8c736f7ded61f5fa0">SendBreak</a> (bool bSend)</td></tr>
<tr class="memdesc:ad9eadeec256969f8c736f7ded61f5fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets or clears a break condition.  <a href="#ad9eadeec256969f8c736f7ded61f5fa0">More...</a><br /></td></tr>
<tr class="separator:ad9eadeec256969f8c736f7ded61f5fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a981f54b3c31a06d18984f28b0f048c61"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html">USBSerialDevice</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html#a981f54b3c31a06d18984f28b0f048c61">getInstance</a> ()</td></tr>
<tr class="memdesc:a981f54b3c31a06d18984f28b0f048c61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the instance of the <a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html" title="Device for serial communication.">USBSerialDevice</a>.  <a href="#a981f54b3c31a06d18984f28b0f048c61">More...</a><br /></td></tr>
<tr class="separator:a981f54b3c31a06d18984f28b0f048c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa34711870fe1fd4c849cb5e78683b184"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html#aa34711870fe1fd4c849cb5e78683b184">registerControlHandler</a> (tUSBCallback cHandler)</td></tr>
<tr class="memdesc:aa34711870fe1fd4c849cb5e78683b184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new Callback function for the control handler.  <a href="#aa34711870fe1fd4c849cb5e78683b184">More...</a><br /></td></tr>
<tr class="separator:aa34711870fe1fd4c849cb5e78683b184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2498db41fd74bcf943e0e704e7e00801"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html#a2498db41fd74bcf943e0e704e7e00801">registerRxHandler</a> (tUSBCallback rHandler)</td></tr>
<tr class="memdesc:a2498db41fd74bcf943e0e704e7e00801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new Callback function for the receive handler.  <a href="#a2498db41fd74bcf943e0e704e7e00801">More...</a><br /></td></tr>
<tr class="separator:a2498db41fd74bcf943e0e704e7e00801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a783a4765110ca9f823cb54f45909cb40"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html#a783a4765110ca9f823cb54f45909cb40">registerTxHandler</a> (tUSBCallback tHandler)</td></tr>
<tr class="memdesc:a783a4765110ca9f823cb54f45909cb40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new Callback function for the transmit handler.  <a href="#a783a4765110ca9f823cb54f45909cb40">More...</a><br /></td></tr>
<tr class="separator:a783a4765110ca9f823cb54f45909cb40"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Device for serial communication. </p>
<p>A device that enables a serial communication with the host. It provides methods to configure the connection, to write in the transmit buffer and read from the receive buffer. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a3c912443871746f9eef7b41c8511442f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c912443871746f9eef7b41c8511442f">&#9670;&nbsp;</a></span>CheckForSerialStateChange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbdevice::USBSerialDevice::CheckForSerialStateChange </td>
          <td>(</td>
          <td class="paramtype">const tUSBDCDCDevice *&#160;</td>
          <td class="paramname"><em>psDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>i32Errors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks the error flags and reacts accordingly. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psDevice</td><td>- the serial device struct </td></tr>
    <tr><td class="paramname">i32Errors</td><td>- error flags</td></tr>
  </table>
  </dd>
</dl>
<p>This function is called whenever serial data is received from the UART. It is passed the accumulated error flags from each character received in this interrupt and determines from them whether or not an interrupt notification to the host is required.</p>
<p>If a notification is required and the control interrupt endpoint is idle, we send the notification immediately. If the endpoint is not idle, we accumulate the errors in a global variable which will be checked on completion of the previous notification and used to send a second one if necessary.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a98c7f10fd7e7526f23e40525c7e2c82a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c7f10fd7e7526f23e40525c7e2c82a">&#9670;&nbsp;</a></span>commandStatusUpdated()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool usbdevice::USBSerialDevice::commandStatusUpdated </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates weather the COMMAND_STATUS_UPDATE flag is that. </p>
<p>Returns the command status update flag as bool.</p>
<dl class="section return"><dt>Returns</dt><dd>bool - command status update flag as bool. </dd></dl>

</div>
</div>
<a id="aea702b8353c899e212b7b20ec8c2774d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea702b8353c899e212b7b20ec8c2774d">&#9670;&nbsp;</a></span>connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbdevice::USBSerialDevice::connected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when new connection appeared. </p>
<p>Configures new connection by flushing the rxBuffer and txBuffer and by dis- and enabling the master interrupt. Set g_bUSBConfigured to true and status to connected.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a97d2e06a99ef4caceff956843f6036de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97d2e06a99ef4caceff956843f6036de">&#9670;&nbsp;</a></span>disconnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbdevice::USBSerialDevice::disconnected </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Called when a conncection is closed. </p>
<p>Dis- and enables the master interrupt. Set g_bUSBConfigured to false and status to disconnected.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="ab8ddf5d93912f8805380c077d7a2a9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ddf5d93912f8805380c077d7a2a9dc">&#9670;&nbsp;</a></span>flushReceiveBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbdevice::USBSerialDevice::flushReceiveBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flushes the receive buffer which is accessible from the user. </p>
<p>The receive buffer is flush by writing 0 to each slot of the buffer. </p>

</div>
</div>
<a id="a981f54b3c31a06d18984f28b0f048c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981f54b3c31a06d18984f28b0f048c61">&#9670;&nbsp;</a></span>getInstance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html">USBSerialDevice</a> * usbdevice::USBSerialDevice::getInstance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the instance of the <a class="el" href="classusbdevice_1_1_u_s_b_serial_device.html" title="Device for serial communication.">USBSerialDevice</a>. </p>
<p>The function creates the object the first time it is called and return the pointer to the object. The object is created on the heap. Later calls only return the pointer to this object.</p>
<dl class="section return"><dt>Returns</dt><dd>- the instance of serial device </dd></dl>

</div>
</div>
<a id="ace75598fb46d690a478f7cf924c497ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace75598fb46d690a478f7cf924c497ad">&#9670;&nbsp;</a></span>GetLineCoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbdevice::USBSerialDevice::GetLineCoding </td>
          <td>(</td>
          <td class="paramtype">tLineCoding *&#160;</td>
          <td class="paramname"><em>psLineCoding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the communication parameters in use on the UART. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psLineCoding</td><td>Contains the informations for the line coding</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a623767d4a33912d98fb84482c4e54774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a623767d4a33912d98fb84482c4e54774">&#9670;&nbsp;</a></span>getReceiveBufferLength()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t usbdevice::USBSerialDevice::getReceiveBufferLength </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the length of the user accessible reciveBuffer. </p>
<p>Returns the length of the user accessible reciveBuffer.</p>
<dl class="section return"><dt>Returns</dt><dd>uint32_t - length of the buffer. </dd></dl>

</div>
</div>
<a id="a7bc9ec56cb3fd6e82d5dc535a12b7206"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bc9ec56cb3fd6e82d5dc535a12b7206">&#9670;&nbsp;</a></span>getRxEventCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t usbdevice::USBSerialDevice::getRxEventCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the number of receive events. </p>
<p>Returns the number of receive events.</p>
<dl class="section return"><dt>Returns</dt><dd>uint32_t - number of receive events. </dd></dl>

</div>
</div>
<a id="ae6d8813297fdb77ae424cfe22eabadac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d8813297fdb77ae424cfe22eabadac">&#9670;&nbsp;</a></span>getSerialDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tUSBDCDCDevice * usbdevice::USBSerialDevice::getSerialDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Getter for the g_sCDCDevice attribute. </p>
<p>Returns the g_sCDCDevice.</p>
<dl class="section return"><dt>Returns</dt><dd>tUSBDCDCDevice - the struct standing for the keyboard device. </dd></dl>

</div>
</div>
<a id="ad2721ebfd4cb57801e8137482a518edf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2721ebfd4cb57801e8137482a518edf">&#9670;&nbsp;</a></span>initBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbdevice::USBSerialDevice::initBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the transmit and receive buffers. </p>
<p>Initializes the rx and tx buffers by calling USBBufferInit() for both buffers.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="aa54a952b46225b35c90c97b5b5896ff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa54a952b46225b35c90c97b5b5896ff8">&#9670;&nbsp;</a></span>popReceiveBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t usbdevice::USBSerialDevice::popReceiveBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns top of queue. </p>
<dl class="section return"><dt>Returns</dt><dd>uint8_t Returns the first byte of receive queue </dd></dl>

</div>
</div>
<a id="a57629924cbdfad86e932cda3c46acce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57629924cbdfad86e932cda3c46acce5">&#9670;&nbsp;</a></span>pushReceiveBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int usbdevice::USBSerialDevice::pushReceiveBuffer </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds add the end of the queue. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data that should be added to the queue</td></tr>
  </table>
  </dd>
</dl>
<p>The data is added to the end of the queue. If the queue is full, the new data discarded.</p>
<dl class="section return"><dt>Returns</dt><dd>int - 0 if the buffer is full. 1 otherwise. </dd></dl>

</div>
</div>
<a id="acca2b3c4990e877940768e3ee02e9400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca2b3c4990e877940768e3ee02e9400">&#9670;&nbsp;</a></span>readBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbdevice::USBSerialDevice::readBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes data from the rxBuffer into the receive buffer. </p>
<p>Reads the rx Buffer and writes the data into the receive buffer. After this the rx buffer gets flushed by calling USBPrimeTransmitt().</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="aa34711870fe1fd4c849cb5e78683b184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa34711870fe1fd4c849cb5e78683b184">&#9670;&nbsp;</a></span>registerControlHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usbdevice::USBSerialDevice::registerControlHandler </td>
          <td>(</td>
          <td class="paramtype">tUSBCallback&#160;</td>
          <td class="paramname"><em>cHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a new Callback function for the control handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cHandler</td><td>New callback method</td></tr>
  </table>
  </dd>
</dl>
<p>The handler handles general USB events like connecting or disconnecting events. A new handler can only be set before the device is referenced the first time. When the device is referenced the first time, the composite device struct is initialized with the current callback method by calling the constructor of the composite device. After that there is no possibility to change the callback method. It can only be one function registered.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a2498db41fd74bcf943e0e704e7e00801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2498db41fd74bcf943e0e704e7e00801">&#9670;&nbsp;</a></span>registerRxHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usbdevice::USBSerialDevice::registerRxHandler </td>
          <td>(</td>
          <td class="paramtype">tUSBCallback&#160;</td>
          <td class="paramname"><em>rHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a new Callback function for the receive handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rHandler</td><td>New callback method</td></tr>
  </table>
  </dd>
</dl>
<p>The handler handles receive events. A new handler can only be set before the device is referenced the first time. When the device is referenced the first time, the composite device struct is initialized with the current callback method by calling the constructor of the composite device. After that there is no possibility to change the callback method. It can only be one function registered.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a783a4765110ca9f823cb54f45909cb40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783a4765110ca9f823cb54f45909cb40">&#9670;&nbsp;</a></span>registerTxHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void usbdevice::USBSerialDevice::registerTxHandler </td>
          <td>(</td>
          <td class="paramtype">tUSBCallback&#160;</td>
          <td class="paramname"><em>tHandler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Registers a new Callback function for the transmit handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tHandler</td><td>New callback method</td></tr>
  </table>
  </dd>
</dl>
<p>The handler handles transmit events. A new handler can only be set before the device is referenced the first time. When the device is referenced the first time, the composite device struct is initialized with the current callback method by calling the constructor of the composite device. After that there is no possibility to change the callback method. It can only be one function registered.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a871027e87d727d295f96489f15d29d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871027e87d727d295f96489f15d29d2f">&#9670;&nbsp;</a></span>resetCommandStatusFlag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbdevice::USBSerialDevice::resetCommandStatusFlag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets command status flag. </p>
<p>Command status flag is set to 0.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="ad9eadeec256969f8c736f7ded61f5fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9eadeec256969f8c736f7ded61f5fa0">&#9670;&nbsp;</a></span>SendBreak()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbdevice::USBSerialDevice::SendBreak </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>bSend</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets or clears a break condition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bSend</td><td>Indicating weather to set or clear break condition</td></tr>
  </table>
  </dd>
</dl>
<p>This function sets or clears a break condition on the redirected UART RX line. A break is started when the function is called with bSend set to true and persists until the function is called again with bSend set to false.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="a46805f59e2e3bf567348897f311c9b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46805f59e2e3bf567348897f311c9b95">&#9670;&nbsp;</a></span>SetControlLineState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbdevice::USBSerialDevice::SetControlLineState </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>ui16State</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the state of the RS232 RTS and DTR signals. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ui16State</td><td>State informations</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<a id="ae42671dfee2a661cd0a88a52ca52e289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae42671dfee2a661cd0a88a52ca52e289">&#9670;&nbsp;</a></span>SetLineCoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool usbdevice::USBSerialDevice::SetLineCoding </td>
          <td>(</td>
          <td class="paramtype">tLineCoding *&#160;</td>
          <td class="paramname"><em>psLineCoding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the communication parameters to use on the UART. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">psLineCoding</td><td>Contains the informations for the line coding which should be set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool - true when setting of the line coding was successfull, false otherwise. </dd></dl>

</div>
</div>
<a id="a6f1bcae7c6437cd73d02915e32403514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f1bcae7c6437cd73d02915e32403514">&#9670;&nbsp;</a></span>USBUARTPrimeTransmit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbdevice::USBSerialDevice::USBUARTPrimeTransmit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take as many bytes from the transmit buffer as we have space for and move them into the USB UART's transmit FIFO. Afterwards the rx buffer is flushed. </p>

</div>
</div>
<a id="af3884b6ffd4ec034716b20f5b330d085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3884b6ffd4ec034716b20f5b330d085">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void usbdevice::USBSerialDevice::write </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes data in transmit buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Pointer to the data that shell be transmit. </td></tr>
    <tr><td class="paramname">length</td><td>Length of the data that shell be transmit.</td></tr>
  </table>
  </dd>
</dl>
<p>Calls USBBufferWrite() to write the data into the txBuffer.</p>
<dl class="section return"><dt>Returns</dt><dd>void </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>device/src/usb/<a class="el" href="_u_s_b_serial_device_8h_source.html">USBSerialDevice.h</a></li>
<li>device/src/usb/<a class="el" href="_u_s_b_serial_device_8cpp.html">USBSerialDevice.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
